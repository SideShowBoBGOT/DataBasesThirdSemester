-- Лабораторна робота № 5. Основи програмування з використанням мови SQL. Збережені процедури. Курсори. Створення, програмування та керування тригерами.
--
--          Виконавець: ІП-11 Панченко Сергій
--          Варіант: 23
--
--            Мета:          * Вивчити правила побудови ідентифікаторів, правила визначення змінних
                          --       та типів. Визначити правила роботи з циклами та умовними
                          --       конструкціями, роботу зі змінними типу Table.

                          -- * Вивчити синтаксис та семантику функцій та збережених процедур,
                          --       способів їх ідентифікації, методів визначення та специфікації параметрів
                          --       та повертаємих значень, виклик функцій та збережених процедур.

                          -- * Застосування команд для створення, зміни та видалення як скалярних, так
                          --       і табличних функцій, збережених процедур.

                          -- * Вивчити призначення та типи курсорів, синтаксис та семантику команд
                          --       мови SQL для створення курсорів, вибірки даних з курсорів, зміни даних
                          --       із застосуванням курсорів.

                          -- * Вивчити призначення та типи тригерів, умов їх активації, синтаксису та
                          --       семантики для їх створення, модифікації, перейменування, програмування
                          --       та видалення.
--
--                Програмне забезпечення аптеки. Аптека продає медикаменти і
--                виготовляє їх за рецептами. Ліки можуть бути різних типів:
--                a. готові ліки: таблетки, мазі, настоянки;
--                b. виготовлені аптекою: мікстури, мазі, розчини, настойки, порошки.
--                Різниця в типах ліків відображається в різному наборі атрибутів, що їх
--                характеризують. В аптеці існує довідник технологій приготування різних
--                ліків. У ньому вказуються: ідентифікаційний номер технології, назву ліків
--                і сам спосіб приготування. На складі на всі медикаменти встановлюється
--                критична норма, тобто коли будь-яких препаратів на складі менше
--                критичної норми, то складаються заявки на них і їх в терміновому
--                порядку привозять з оптових складів медикаментів. Для виготовлення
--                аптекою ліків хворий повинен принести рецепт від лікаря. У рецепті
--                повинно бути вказано: ПІБ, підпис і печатка лікаря, ПІБ, вік та діагноз
--                пацієнта, також кількість ліків і спосіб застосування. Хворий віддаєрецепт реєстратору, він приймає замовлення і дивиться, чи все є в
--                наявності. Якщо не всі ліки є в наявності, такий хворий поповнює
--                довідник замовлень з позначкою, що не всі компоненти є для замовлення.
--                Якщо всі компоненти є, то вони резервуються для хворого. Покупець
--                сплачує ціну ліків, йому повертається рецепт з позначкою про час
--                виготовлення. У призначений час хворий приходить і за тим самим
--                рецептом отримує готове ліки. Такий хворий поповнює список відданих
--                замовлень. Ведеться статистика за обсягами використовуваних
--                медикаментів.

-- 0) Створимо таблиці та заповнимо їх данними:

    create database lab_five;
    \c lab_five

    create table preparation_type (
        id int generated by default as identity primary key,
        name varchar(40)
    );
    create table medicine ( 
        id int generated by default as identity primary key,
        name varchar(40),
        total_bought int,
        total_quant int,
        crit_quant int,
        prep_id serial
    );

    alter table medicine add constraint fk_preparation_type_on_medice
    foreign key (prep_id) references preparation_type (id) on update cascade on delete restrict;

    create table storage (
        id int generated by default as identity primary key,
        name varchar(40)
    );

    create table storage_medicine (
        id int generated by default as identity primary key,
        stor_id serial,
        med_id serial
    );

    alter table storage_medicine add constraint fk_med_on_stor_med
    foreign key (med_id) references medicine (id) on update cascade on delete restrict;

    create table warehouse (
        id int generated by default as identity primary key,
        name varchar(40)
    );

    create table warehouse_request (
        id serial,
        med_id serial,
        stor_id serial,
        war_id serial
    );

    alter table warehouse_request add constraint fk_med_on_war_req
    foreign key (med_id) references medicine (id) on update cascade on delete restrict;

    alter table warehouse_request add constraint fk_stor_on_war_req
    foreign key (stor_id) references storage (id) on update cascade on delete restrict;

    alter table warehouse_request add constraint fk_war_on_war_req
    foreign key (war_id) references warehouse (id) on update cascade on delete restrict;

    create table orders (
        id int generated by default as identity primary key,
        doc_name varchar(40),
        doc_code int check (doc_code > 0),
        use_type varchar(40),
        pac_name varchar(40),
        pac_age int check (pac_age > 0),
        med_num int check (med_num > 0),
        prep_date timestamp,
        price float check(price >= 0)
    );

    create table orders_medicine (
        id int generated by default as identity primary key,
        is_res bool,
        ord_id serial,
        med_id serial
    );  

    alter table orders_medicine add constraint fk_ord_on_ord_med
    foreign key (ord_id) references orders (id) on update cascade on delete restrict;

    alter table orders_medicine add constraint fk_med_on_ord_med
    foreign key (med_id) references medicine (id) on update cascade on delete restrict;

    -- Заповнимо таблицю рядками:
    insert into preparation_type values (default, 'carbonization');
    insert into preparation_type values (default, 'cancerezation');
    insert into preparation_type values (default, 'pressuring');
    insert into preparation_type values (default, 'solarization');

    insert into medicine values (default, 'Tealoz Duo', 4, 35, 2, 2);
    insert into medicine values (default, 'PanzerLac', 23, 120, 19, 4);
    insert into medicine values (default, 'Laplas', 4, 50, 2, 3);
    insert into medicine values (default, 'Riamot', 9, 40, 12, 2);
    insert into medicine values (default, 'Macert', 9, 70, 15, 1);
    insert into medicine values (default, 'APlus', NULL, 45, 5, 3);
    insert into medicine values (default, 'StarWater', NULL, 87, 4, 4);
    insert into medicine values (default, 'AntiTrauma', 2, 7, 4, 1);
    insert into medicine values (default, 'RedLight', 2, 5, 4, 1);
    insert into medicine values (default, 'ClassFoster', 2, 9, 4, 1);

    insert into storage values (default, 'storage_one');
    insert into storage values (default, 'storage_two');
    insert into storage values (default, 'storage_three');
    insert into storage values (default, 'storage_four');
    insert into storage values (default, 'storage_five');
    insert into storage values (default, 'storage_six');
    insert into storage values (default, 'storage_seven');

    insert into storage_medicine values (default, 1, 1);
    insert into storage_medicine values (default, 1, 4);
    insert into storage_medicine values (default, 2, 2);
    insert into storage_medicine values (default, 3, 3);
    insert into storage_medicine values (default, 3, 7);
    insert into storage_medicine values (default, 3, 1);
    insert into storage_medicine values (default, 4, 2);
    insert into storage_medicine values (default, 4, 1);
    insert into storage_medicine values (default, 5, 4);
    insert into storage_medicine values (default, 6, 1);
    insert into storage_medicine values (default, 6, 2);
    insert into storage_medicine values (default, 6, 6);
    insert into storage_medicine values (default, 6, 5);
    insert into storage_medicine values (default, 7, 1);
    insert into storage_medicine values (default, 7, 3);
    insert into storage_medicine values (default, 7, 5);
    insert into storage_medicine values (default, 7, 4);

    insert into warehouse values (default, 'warehouse_one');
    insert into warehouse values (default, 'warehouse_two');
    insert into warehouse values (default, 'warehouse_three');
    insert into warehouse values (default, 'warehouse_four');
    insert into warehouse values (default, 'warehouse_five');
    insert into warehouse values (default, 'warehouse_six');
    insert into warehouse values (default, 'warehouse_seven');

    insert into warehouse_request values (default, 1, 1, 1);
    insert into warehouse_request values (default, 2, 2, 1);
    insert into warehouse_request values (default, 2, 2, 2);
    insert into warehouse_request values (default, 3, 1, 1);
    insert into warehouse_request values (default, 2, 3, 4);
    insert into warehouse_request values (default, 2, 1, 3);
    insert into warehouse_request values (default, 3, 3, 3);
                     
    insert into orders values (default, 'Tyler Durden', 2217854, 'Drinking', 'The Narrator', 30, 1, '2022-10-22 14:00:00', 180.56);
    insert into orders values (default, 'Saul Goodman', 20082013, 'Chewing', 'Walter White', 50, 5, '2022-11-23 18:30:00', 503.45);
    insert into orders values (default, 'Trevis Bickle', 4322013, 'Snoring', 'Betsy White', 20, 15, '2022-01-23 19:30:00', 503.45);
    insert into orders values (default, 'Mario Mario', 82013, 'Sniffing', 'Luigi Mario', 50, 5, '2022-11-11 20:30:00', 102.45);
    insert into orders values (default, 'Robocop', 20082013, 'Sucking', 'Terminator', 50, 5, '2022-04-19 21:30:00', 503.45);
    insert into orders values (default, 'Serhii Panchenko', 666666, 'Formalizing', 'Natalia Cegla', 18, 81, '2022-04-19 21:30:00', 503.99);
    insert into orders values (default, 'Yurii Riabov', 101010101, 'Animezation', 'Vlad Golovatuk', 19, 21, '2022-11-30 19:20:00', 108.56);
    insert into orders values (default, 'Dmytro Tarasonok', 1234567, 'Cabanizaton', 'Vano Sheet', 20, 11, '2022-11-29 22:40:00', 73.34);
    insert into orders values (default, 'Kyrylo Sidak', 666999, 'Pythonization', 'Kipish SMS', 6, 13, '2022-04-19 21:30:00', 13.11);

    insert into orders_medicine values (default, false, 1, 1);
    insert into orders_medicine values (default, true, 1, 2);
    insert into orders_medicine values (default, true, 3, 4);
    insert into orders_medicine values (default, true, 4, 5);
    insert into orders_medicine values (default, false, 1, 6);
    insert into orders_medicine values (default, false, 7, 2);
    insert into orders_medicine values (default, false, 2, 3);
    insert into orders_medicine values (default, false, 3, 5);
    insert into orders_medicine values (default, false, 5, 4);
    insert into orders_medicine values (default, false, 4, 1);
    insert into orders_medicine values (default, false, 4, 6);


-- Постановка задачі лабораторної робота № 5
-- При виконанні лабораторної роботи необхідно виконати наступні дії:
-- 1) Збережені процедури:
    -- a. запит для створення тимчасової таблиці через змінну типу TABLE;

        -- Створимо нову тимчасову таблицю, яка є копією Preparation type;

            create temporary table pacients (
                id int generated by default as identity primary key,
                name varchar(40)
            ) on commit delete rows;

            \d
            --                         List of relations
            --   Schema   |             Name              |   Type   |  Owner   
            -- -----------+-------------------------------+----------+----------
            --  pg_temp_5 | pacients                      | table    | postgres
            --  pg_temp_5 | pacients_id_seq               | sequence | postgres

    -- b. запит з використанням умовної конструкції IF;

        -- IF не можна використовувати поза процедурами та функціями
        -- Визначимо, яких ліків достатньо, тобто більше 10 одиниць,
        -- де додамо колонку IF та позначимо, чи достатньо

            create or replace function enough_func(
                num int
            )
            returns bool as
            $$
            declare more bool;
            begin
                if num > 10 then
                    more := true;
                else
                    more := false;
                end if;
                return more;
            end;
            $$
            language plpgsql;


            select name, total_quant, enough_func(total_quant) from medicine;

             
            --     name     | total_quant | enough_func 
            -- -------------+-------------+-------------
            --  Tealoz Duo  |          35 | t
            --  PanzerLac   |         120 | t
            --  Laplas      |          50 | t
            --  Riamot      |          40 | t
            --  Macert      |          70 | t
            --  APlus       |          45 | t
            --  StarWater   |          87 | t
            --  AntiTrauma  |           7 | f
            --  RedLight    |           5 | f
            --  ClassFoster |           9 | f


    -- c. запит з використанням циклу WHILE;

        -- Створимо для оновлення ID таблиці Складів у циклі:
            
            DO $$
            declare
                    counter int;
                    max_id int;
            begin
                counter := 1;
                max_id := 7;
                while counter <= max_id loop
                    update storage
                    set id = counter * 10
                    where id = counter;
                    counter := counter + 1;
                END loop;
            end
            $$;

            -- ДО ВИКОНАННЯ WhileUpdate:
                select * from storage;
                --  id |     name      
                -- ----+---------------
                --   1 | storage_one
                --   2 | storage_two
                --   3 | storage_three
                --   4 | storage_four
                --   5 | storage_five
                --   6 | storage_six
                --   7 | storage_seven

            -- ПІСЛЯ:
                select * from storage;
                --  id |     name      
                -- ----+---------------
                --  10 | storage_one
                --  20 | storage_two
                --  30 | storage_three
                --  40 | storage_four
                --  50 | storage_five
                --  60 | storage_six
                --  70 | storage_seven

    -- d. створення процедури без параметрів;

        -- Створимо процедуру, яка оновлює назву склада з індексом 70 :

            create or replace procedure update_seventy()
            language plpgsql
            as $$
            begin
                update storage set name = 'storage_seven_update' where id = 70;
            end
            $$;

            --  id |     name      
            -- ----+---------------
            --  70 | storage_seven

            -- call update_seventy();
            --  id |         name         
            -- ----+----------------------
            --  70 | storage_seven_update



    -- e. створення процедури з вхідним параметром;

        -- оновимо назву складу за його індексом

            create or replace procedure name_by_id(_id int)
            language plpgsql
            as $$
            begin
                update storage set name = concat(name, '_update') where id = _id; 
            end
            $$;

            select * from storage;

            --  id |         name         
            -- ----+----------------------
            --  10 | storage_one
            --  20 | storage_two
            --  30 | storage_three
            --  40 | storage_four
            --  50 | storage_five
            --  60 | storage_six
            --  70 | storage_seven_update


            call name_by_id(10);
            call name_by_id(40);
            select * from storage;
            --  id |         name         
            -- ----+----------------------
            --  20 | storage_two
            --  30 | storage_three
            --  50 | storage_five
            --  60 | storage_six
            --  70 | storage_seven_update
            --  10 | storage_one_update
            --  40 | storage_four_update


    -- f. створення процедури з вхідним параметром та RETURN;

        -- Підрахуємо кількість усього куплених ліків
        -- та повернемо значення у вихідно зімнну

        create or replace procedure tot_buy(inout buy int)
        language plpgsql
        as $$
        begin
            select sum(total_bought) INTO buy from medicine;
            return;
        end
        $$;

        call tot_buy(1);

         buy 
        -----
          55

    -- g. створення процедури оновлення даних в деякій таблиці БД;

        --- Створимо процедуру для оновлення даних таблиці складів

                create or replace procedure update_storage(_id int, _name varchar(40))
                language plpgsql
                as $$
                begin
                    update storage
                    set name = _name
                    WHERE id = _id;
                end
                $$;

                call update_storage(70, 'storage_70');
                call update_storage(40, 'storage_40');
                call update_storage(50, 'storage_50');

                --  id |        name        
                -- ----+--------------------
                --  20 | storage_two
                --  30 | storage_three
                --  60 | storage_six
                --  10 | storage_one_update
                --  70 | storage_70
                --  40 | storage_40
                --  50 | storage_50



    -- h. створення процедури, в котрій робиться вибірка даних.

        -- Визначимо перший склад, де назва містить '0':

            create or replace procedure fname(INOUT _row text)
            language plpgsql
            as $$
            begin
                select name into _row from storage where name like '%0%' limit 1;
            end
            $$;

            call fname('r');

            --     _row    
            -- ------------
            --  storage_70


-- 2) Функції:
    -- a. створити функцію, котра повертає деяке скалярне значення;
        -- Створимо функцію для визначення загальної витраченої
        -- кількості грошей клієнтами на ліки

            create or replace function total_money()
            returns int
            language plpgsql
            as $$
                declare tot_money int;
            begin
                tot_money := 0;
                select sum(price) into tot_money from orders;
                return tot_money;
            end
            $$;

            -- select total_money();
            --  total_money 
            -- -------------
            --         2492

    -- b. створити функцію, котра повертає таблицю з динамічним набором
    -- стовпців;

        -- створимо функцію, яка повертає таблицю імен пацієнтів,
        -- за заданою кількістю

            create or replace function dynamic_table(in _rows int)
            returns setof record
            language plpgsql
            as $$
            declare
                r record;
            begin
                for r in select pac_name from orders limit _rows loop
                    return next r;
                end loop;
            end
            $$;

            select * from dynamic_table(3) as (name varchar(40));

            --      name     
            -- --------------
            --  The Narrator
            --  Walter White
            --  Betsy White

            select * from dynamic_table(5) as (name varchar(40));
            --      name     
            -- --------------
            --  The Narrator
            --  Walter White
            --  Betsy White
            --  Luigi Mario
            --  Terminator


    -- c. створити функцію, котра повертає таблицю заданої структури.

        -- Створимо таблицю, яка повертає назви ліків, кількість яких,
        -- більша 50

        create or replace function med_more_fifty()
        returns table(_name varchar(40), _tot_quant int)
        language plpgsql
        as $$
        begin
            return query select name, total_quant from medicine where total_quant > 50;
        end
        $$; 

        select * from med_more_fifty();
        --    _name   | _tot_quant 
        -- -----------+------------
        --  PanzerLac |        120
        --  Macert    |         70
        --  StarWater |         87


-- 3) Робота з курсорами:
    -- a. b створити курсор;

        -- створимо курсор для визначення ліків та способу їх приготування

            begin work;
            declare med_cursor cursor for
            select medicine.name, preparation_type.name from medicine
            inner join preparation_type
            on medicine.prep_id = preparation_type.id;
            commit;
            end work;

    -- c. вибірка даних, робота з курсорами.

        -- вибиберемо поля з курсора

            fetch all from med_cursor;
            --     name     |     name      
            -- -------------+---------------
            --  Tealoz Duo  | cancerezation
            --  PanzerLac   | solarization
            --  Laplas      | pressuring
            --  Riamot      | cancerezation
            --  Macert      | carbonization
            --  APlus       | pressuring
            --  StarWater   | solarization
            --  AntiTrauma  | carbonization
            --  RedLight    | carbonization
            --  ClassFoster | carbonization


-- 4) Робота з тригерами:

    -- створимо таблицю для логування даних, 
    -- щоб релізувати тригери та бачити зміни в базі даних

        create table log (
            username text,
            event_time_utc timestamp,
            table_name text,
            operation text
        );

        -- створимо тригер для логування даних одночасно
        -- для видаленняб модифікації тп додавання



        -- створимо логування для medicine

    -- a. створити тригер, котрий буде спрацьовувати при видаленні даних;

        create or replace function log_delete_trigger()
            returns trigger
        language plpgsql
        as $$
        begin
            insert into log values (
                session_user,
                current_timestamp at time zone 'utc',
                tg_table_schema || '.' || tg_table_name,
                'delete'
            );
            return new;
        end
        $$;

        create trigger med_delete_trigger
        after delete
        on medicine
        for each row
        execute procedure log_delete_trigger();

        delete from storage_medicine where med_id = 6;
        -- DELETE 1
        delete from orders_medicine where med_id = 6;
        -- DELETE 2
        delete from medicine where id = 6;
        -- DELETE 1
        select * from log;
        --  username |       event_time_utc       |   table_name    | operation 
        -- ----------+----------------------------+-----------------+-----------
        --  postgres | 2022-12-10 15:20:53.117339 | public.medicine | delete

    -- c. створити тригер, котрий буде спрацьовувати при додаванні даних.

        create or replace function log_insert_trigger()
            returns trigger
        language plpgsql
        as $$
        begin
            insert into log values (
                session_user,
                current_timestamp at time zone 'utc',
                tg_table_schema || '.' || tg_table_name,
                'insert'
            );
            return new;
        end
        $$;

        create trigger med_insert_trigger
        after insert
        on medicine
        for each row
        execute procedure log_insert_trigger();

        insert into medicine values (default, 'Milomax', 7, 22, 1, 1);
        --  username |       event_time_utc       |   table_name    | operation 
        -- ----------+----------------------------+-----------------+-----------
        --  postgres | 2022-12-10 15:20:53.117339 | public.medicine | delete
        --  postgres | 2022-12-10 15:24:06.091925 | public.medicine | insert


    -- b. створити тригер, котрий буде спрацьовувати при модифікації даних;

        create or replace function log_update_trigger()
            returns trigger
        language plpgsql
        as $$
        begin
            insert into log values (
                session_user,
                current_timestamp at time zone 'utc',
                tg_table_schema || '.' || tg_table_name,
                'update'
            );
            return new;
        end
        $$;

        create or replace trigger med_update_trigger
        after update
        on medicine
        for each row
        execute procedure log_update_trigger();

        update medicine set name = 'Lofipop' where id = 5;

        --  username |       event_time_utc       |   table_name    | operation 
        -- ----------+----------------------------+-----------------+-----------
        --  postgres | 2022-12-10 15:20:53.117339 | public.medicine | delete
        --  postgres | 2022-12-10 15:24:06.091925 | public.medicine | insert
        --  postgres | 2022-12-10 15:25:46.147055 | public.medicine | update




















        
